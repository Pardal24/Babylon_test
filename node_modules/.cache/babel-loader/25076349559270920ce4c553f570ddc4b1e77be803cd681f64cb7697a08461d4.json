{"ast":null,"code":"export const transform = (cv, docCanvas, cropPoints, imageResizeRatio, setPreviewPaneDimensions) => {\n  const dst = cv.imread(docCanvas);\n  const bR = cropPoints['right-bottom'];\n  const bL = cropPoints['left-bottom'];\n  const tR = cropPoints['right-top'];\n  const tL = cropPoints['left-top'];\n\n  // create source coordinates matrix\n  const sourceCoordinates = [tL, tR, bR, bL].map(point => [point.x / imageResizeRatio, point.y / imageResizeRatio]);\n  console.log('source_cord: ', sourceCoordinates);\n\n  // get max width\n  const maxWidth = Math.max(bR.x - bL.x, tR.x - tL.x) / imageResizeRatio;\n  // get max height\n  const maxHeight = Math.max(bL.y - tL.y, bR.y - tR.y) / imageResizeRatio;\n\n  // create dest coordinates matrix\n  const destCoordinates = [[0, 0], [2000 - 1, 0], [2000 - 1, 1000 - 1], [0, 1000 - 1]];\n\n  // convert to open cv matrix objects\n  const Ms = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...sourceCoordinates));\n  const Md = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...destCoordinates));\n  const transformMatrix = cv.getPerspectiveTransform(Ms, Md);\n  console.log('TM: ', transformMatrix);\n  // set new image size\n  const dsize = new cv.Size(2000, 1000);\n  // perform warp\n  cv.warpPerspective(dst, dst, transformMatrix, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());\n  cv.imshow(docCanvas, dst);\n  dst.delete();\n  Ms.delete();\n  Md.delete();\n  transformMatrix.delete();\n  setPreviewPaneDimensions();\n};\n\n// export const applyFilter = async (cv, docCanvas, filterCvParams) => {\n//   // default options\n//   const options = {\n//     blur: false,\n//     th: true,\n//     thMode: cv.ADAPTIVE_THRESH_MEAN_C,\n//     thMeanCorrection: 15,\n//     thBlockSize: 25,\n//     thMax: 255,\n//     grayScale: true,\n//     ...filterCvParams\n//   }\n//   const dst = cv.imread(docCanvas)\n\n//   if (options.grayScale) {\n//     cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY, 0)\n//   }\n//   if (options.blur) {\n//     const ksize = new cv.Size(5, 5)\n//     cv.GaussianBlur(dst, dst, ksize, 0, 0, cv.BORDER_DEFAULT)\n//   }\n//   if (options.th) {\n//     if (options.grayScale) {\n//       cv.adaptiveThreshold(\n//         dst,\n//         dst,\n//         options.thMax,\n//         options.thMode,\n//         cv.THRESH_BINARY,\n//         options.thBlockSize,\n//         options.thMeanCorrection\n//       )\n//     } else {\n//       dst.convertTo(dst, -1, 1, 60)\n//       cv.threshold(dst, dst, 170, 255, cv.THRESH_BINARY)\n//     }\n//   }\n//   cv.imshow(docCanvas, dst)\n// }","map":{"version":3,"names":["transform","cv","docCanvas","cropPoints","imageResizeRatio","setPreviewPaneDimensions","dst","imread","bR","bL","tR","tL","sourceCoordinates","map","point","x","y","console","log","maxWidth","Math","max","maxHeight","destCoordinates","Ms","matFromArray","CV_32FC2","concat","Md","transformMatrix","getPerspectiveTransform","dsize","Size","warpPerspective","INTER_LINEAR","BORDER_CONSTANT","Scalar","imshow","delete"],"sources":["/home/fpardal/Desktop/cropper/src/lib/imgManipulation.js"],"sourcesContent":["export const transform = (\n  cv,\n  docCanvas,\n  cropPoints,\n  imageResizeRatio,\n  setPreviewPaneDimensions\n) => {\n  const dst = cv.imread(docCanvas)\n\n  const bR = cropPoints['right-bottom']\n  const bL = cropPoints['left-bottom']\n  const tR = cropPoints['right-top']\n  const tL = cropPoints['left-top']\n\n  // create source coordinates matrix\n  const sourceCoordinates = [tL, tR, bR, bL].map((point) => [\n    point.x / imageResizeRatio,\n    point.y / imageResizeRatio\n  ])\n  console.log('source_cord: ', sourceCoordinates);\n\n  // get max width\n  const maxWidth = Math.max(bR.x - bL.x, tR.x - tL.x) / imageResizeRatio\n  // get max height\n  const maxHeight = Math.max(bL.y - tL.y, bR.y - tR.y) / imageResizeRatio\n\n  // create dest coordinates matrix\n  const destCoordinates = [\n    [0, 0],\n    [2000 - 1, 0],\n    [2000 - 1, 1000 - 1],\n    [0, 1000 - 1]\n  ]\n\n  // convert to open cv matrix objects\n  const Ms = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...sourceCoordinates))\n  const Md = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...destCoordinates))\n  const transformMatrix = cv.getPerspectiveTransform(Ms, Md)\n  console.log('TM: ', transformMatrix);\n  // set new image size\n  const dsize = new cv.Size(2000, 1000)\n  // perform warp\n  cv.warpPerspective(\n    dst,\n    dst,\n    transformMatrix,\n    dsize,\n    cv.INTER_LINEAR,\n    cv.BORDER_CONSTANT,\n    new cv.Scalar()\n  )\n  cv.imshow(docCanvas, dst)\n\n  dst.delete()\n  Ms.delete()\n  Md.delete()\n  transformMatrix.delete()\n\n  setPreviewPaneDimensions()\n}\n\n// export const applyFilter = async (cv, docCanvas, filterCvParams) => {\n//   // default options\n//   const options = {\n//     blur: false,\n//     th: true,\n//     thMode: cv.ADAPTIVE_THRESH_MEAN_C,\n//     thMeanCorrection: 15,\n//     thBlockSize: 25,\n//     thMax: 255,\n//     grayScale: true,\n//     ...filterCvParams\n//   }\n//   const dst = cv.imread(docCanvas)\n\n//   if (options.grayScale) {\n//     cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY, 0)\n//   }\n//   if (options.blur) {\n//     const ksize = new cv.Size(5, 5)\n//     cv.GaussianBlur(dst, dst, ksize, 0, 0, cv.BORDER_DEFAULT)\n//   }\n//   if (options.th) {\n//     if (options.grayScale) {\n//       cv.adaptiveThreshold(\n//         dst,\n//         dst,\n//         options.thMax,\n//         options.thMode,\n//         cv.THRESH_BINARY,\n//         options.thBlockSize,\n//         options.thMeanCorrection\n//       )\n//     } else {\n//       dst.convertTo(dst, -1, 1, 60)\n//       cv.threshold(dst, dst, 170, 255, cv.THRESH_BINARY)\n//     }\n//   }\n//   cv.imshow(docCanvas, dst)\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}